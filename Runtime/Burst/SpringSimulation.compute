#pragma kernel spring_forces
#pragma kernel collision_response
#pragma kernel integrate_forces
#pragma kernel calculate_force_arrows

struct node_data
{
    float2 position;
    float2 velocity;
    float2 force;
    int node_type;
    int parent_id; // ID of the parent GameObject for components, -1 for GameObjects
};

struct arrow_data
{
    float2 start;
    float2 end;
    float strength;
};

RWStructuredBuffer<node_data> nodes;
RWStructuredBuffer<arrow_data> force_arrows;
uint node_count;
float delta_time;
float stiffness;
float damping;
float collider_radius;
float collision_response_strength;
float min_integration_timestep;

// Relaxation parameters
float relaxation_factor; // Will be < 1 during relaxation and 1 when fully relaxed
float max_velocity_limit; // Will increase over time during relaxation

float go_rest_length;
float gc_rest_length;
float cc_rest_length;

// Radial layout parameters
float radial_distance; // Base distance for components around parent
float radial_angle_offset; // Starting angle offset (in radians)
float angle_separation; // Minimum separation between components (in radians)

[numthreads(64,1,1)]
void spring_forces (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= node_count) return;
    
    // Reset force for this node
    nodes[id.x].force = float2(0, 0);
    
    // Special handling for component nodes with a parent
    if (nodes[id.x].node_type == 1 && nodes[id.x].parent_id >= 0)
    {
        // Get parent position
        float2 parent_pos = nodes[nodes[id.x].parent_id].position;
        
        // Count siblings to arrange them properly
        int sibling_count = 0;
        int component_index = 0;
        
        for (uint j = 0; j < node_count; j++)
        {
            if (nodes[j].node_type == 1 && nodes[j].parent_id == nodes[id.x].parent_id)
            {
                if (j < id.x) component_index++;
                sibling_count++;
            }
        }
        
        // Calculate angle for this component based on its index
        float angle_step = 2.0 * 3.14159265 / max(sibling_count, 1);
        float angle = radial_angle_offset + component_index * angle_step;
        
        // Calculate target position in radial layout
        float2 target_pos = parent_pos + float2(cos(angle), sin(angle)) * radial_distance;
        
        // Create strong attractive force toward the target position
        float2 to_target = target_pos - nodes[id.x].position;
        float dist_to_target = length(to_target);
        
        if (dist_to_target > 0.0001f)
        {
            // Stronger force for radial positioning
            float radial_force_strength = stiffness * 15.0 * relaxation_factor;
            nodes[id.x].force += normalize(to_target) * dist_to_target * radial_force_strength;
        }
    }
    
    // Regular spring forces for all nodes
    for (uint j = 0; j < node_count; j++)
    {
        if (id.x == j) continue;
        
        // Calculate displacement between nodes
        float2 displacement = nodes[j].position - nodes[id.x].position;
        float distance = length(displacement);
        
        if (distance < 0.0001f) continue; // Avoid division by zero
        
        // Direction of the force
        float2 direction = displacement / distance;
        
        // Determine interaction stiffness and rest length based on node types
        float node_stiffness = stiffness * relaxation_factor; // Apply a relaxation factor to stiffness
        float rest_length; // Default rest length
        
        // Check if this is a parent-child relationship
        bool is_parent_child = false;
        if (nodes[id.x].node_type == 1 && nodes[j].node_type == 0 && nodes[id.x].parent_id == j) {
            // This component is connected to its parent GameObject
            node_stiffness = stiffness * 10.0 * relaxation_factor; // Very strong connection
            rest_length = radial_distance; // Use radial distance as rest length
            is_parent_child = true;
        }
        else if (nodes[id.x].node_type == 0 && nodes[j].node_type == 1 && nodes[j].parent_id == id.x) {
            // This GameObject is connected to its child component
            node_stiffness = stiffness * 10.0 * relaxation_factor; // Very strong connection
            rest_length = radial_distance; // Use radial distance as rest length
            is_parent_child = true;
        }
        else if (nodes[id.x].node_type == 0 && nodes[j].node_type == 0) 
        {
            // GameObject - GameObject
            node_stiffness = stiffness * 0.1 * relaxation_factor;
            rest_length = go_rest_length;
        }
        else if ((nodes[id.x].node_type == 0 && nodes[j].node_type == 1) ||
                (nodes[id.x].node_type == 1 && nodes[j].node_type == 0)) 
        {
            // GameObject - Component (not parent-child)
            node_stiffness = stiffness * 1.0 * relaxation_factor; // Weaker than parent-child
            rest_length = gc_rest_length * 2.0; // Further apart than parent-child
        }
        else if (nodes[id.x].node_type == 1 && nodes[j].node_type == 1 &&
                 nodes[id.x].parent_id == nodes[j].parent_id && nodes[id.x].parent_id >= 0) 
        {
            // Components that share the same parent GameObject
            // Use angle separation for siblings
            node_stiffness = stiffness * 2.0 * relaxation_factor;
            rest_length = 2.0 * radial_distance * sin(angle_separation / 2.0); // Arc distance
        }
        else {
            // Other Component - Component interactions
            rest_length = cc_rest_length;
        }
        
        // Calculate spring force with rest length
        // F = -k * (|x| - L) * (x/|x|) where L is the rest length
        float spring_magnitude = node_stiffness * (distance - rest_length);
        float2 spring_force = direction * spring_magnitude;
        
        // Apply the spring force
        nodes[id.x].force += spring_force;
        
        // Add a stronger cohesive force for parent-child relationships to maintain the radial structure
        if (is_parent_child && distance > rest_length * 1.2) {
            float2 cohesiveForce = direction * stiffness * 5.0 * relaxation_factor;
            nodes[id.x].force += cohesiveForce;
        }
    }
    
    // Apply damping force - increase damping during relaxation phase
    float effectiveDamping = damping * (2.0 - relaxation_factor); // More damping when relaxationFactor is low
    float2 dampingForce = -effectiveDamping * nodes[id.x].velocity;
    nodes[id.x].force += dampingForce;

    // Add a weak centering force for all nodes
    float2 centerPosition = float2(0, 0);
    for (uint j = 0; j < node_count; j++) {
        centerPosition += nodes[j].position;
    }
    centerPosition /= node_count;
    
    float2 toCenterDir = centerPosition - nodes[id.x].position;
    float centerDist = length(toCenterDir);
    
    if (centerDist > 0.001) {
        // Increase centering force during relaxation, but reduce it for component nodes
        float centerForceMultiplier = nodes[id.x].node_type == 1 ? 0.2 : 1.0;
        float stabilizingForce = 1e-6 * (1.0 + (2.0 - relaxation_factor) * 10.0) * centerForceMultiplier; 
        nodes[id.x].force += normalize(toCenterDir) * stabilizingForce * centerDist;
    }
}

[numthreads(64,1,1)]
void collision_response (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= node_count) return;
    
    float2 position = nodes[id.x].position;
    float2 velocity = nodes[id.x].velocity;
    
    for (int j = 0; (uint)j < node_count; j++)
    {
        if (id.x == (uint)j) continue;
        
        // Skip collision between component and its parent GameObject
        if ((nodes[id.x].node_type == 1 && nodes[j].node_type == 0 && nodes[id.x].parent_id == j) ||
            (nodes[id.x].node_type == 0 && nodes[j].node_type == 1 && nodes[j].parent_id == id.x)) {
            continue;
        }
        
        float2 delta = position - nodes[j].position;
        float distance = length(delta);
        float minDist = collider_radius * 2;
        
        // Reduce minimum distance for components that share the same parent
        if (nodes[id.x].node_type == 1 && nodes[j].node_type == 1 && 
            nodes[id.x].parent_id == nodes[j].parent_id && nodes[id.x].parent_id >= 0) {
            minDist *= 0.75; // Allow sibling components to get closer
        }
        
        if (distance < minDist && distance > 0.0001f)
        {
            float2 direction = delta / distance;
            float overlap = minDist - distance;
            
            // Increase positional correction during relaxation
            float correctionStrength = 0.5f * relaxation_factor + 0.5f;
            position += direction * (overlap * correctionStrength);
            
            float2 relativeVelocity = velocity - nodes[j].velocity;
            float velocityAlongNormal = dot(relativeVelocity, direction);
            
            if (velocityAlongNormal < 0)
            {
                // Adjust restitution based on relaxation
                float restitution = 0.5f * relaxation_factor;
                float j_scalar = -(1 + restitution) * velocityAlongNormal;
                j_scalar *= collision_response_strength * relaxation_factor;
                
                velocity += direction * j_scalar;
            }
        }
    }
    
    nodes[id.x].position = position;
    nodes[id.x].velocity = velocity;

    // For GameObjects, add a mild rotational stabilization for their components
    if (nodes[id.x].node_type == 0) {
        // Find all components belonging to this GameObject
        float2 avgComponentPos = float2(0, 0);
        int componentCount = 0;
        
        for (uint j = 0; j < node_count; j++) {
            if (nodes[j].node_type == 1 && nodes[j].parent_id == id.x) {
                avgComponentPos += nodes[j].position;
                componentCount++;
            }
        }
        
        if (componentCount > 0) {
            avgComponentPos /= componentCount;
            float2 to_avg_component_dir = avgComponentPos - position;
            
            // Add a very weak force to balance components around parent
            if (length(to_avg_component_dir) > 0.1) {
                velocity -= normalize(to_avg_component_dir) * 0.001 * relaxation_factor;
            }
        }
    }

    if (node_count > 1) {
        // Calculate center of mass
        float2 centerOfMass = float2(0, 0);
        for (uint j = 0; j < node_count; j++) {
            centerOfMass += nodes[j].position;
        }
        centerOfMass /= node_count;
        
        // Calculate radial vector
        float2 radialVector = nodes[id.x].position - centerOfMass;
        float distance = length(radialVector);
        
        if (distance > 0.001) {
            // Calculate tangential velocity component
            float2 direction = radialVector / distance;
            float2 tangent = float2(-direction.y, direction.x);
            float tangentialVelocity = dot(nodes[id.x].velocity, tangent);
            
            // Increase angular damping during relaxation
            float angularDamping = 0.05 * (2.0 - relaxation_factor);
            nodes[id.x].velocity -= tangent * tangentialVelocity * angularDamping;
        }
    }
}

[numthreads(64,1,1)]
void integrate_forces (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= node_count) return;
    
    // Use a smaller effective timestep for stability
    float effective_delta_time = min(delta_time, min_integration_timestep);
    
    // Semi-implicit Euler integration
    nodes[id.x].velocity += nodes[id.x].force * effective_delta_time;
    
    // Apply extra damping during relaxation
    float extra_damping = 0.99 * relaxation_factor + 0.9 * (1.0 - relaxation_factor);
    nodes[id.x].velocity *= extra_damping;
    
    // Apply velocity limit - more strict during relaxation
    float current_speed = length(nodes[id.x].velocity);
    if (current_speed > max_velocity_limit) {
        nodes[id.x].velocity = nodes[id.x].velocity / current_speed * max_velocity_limit;
    }
    
    nodes[id.x].position += nodes[id.x].velocity * effective_delta_time;
}

[numthreads(64,1,1)]
void calculate_force_arrows (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= node_count) return;
    
    float force_magnitude = length(nodes[id.x].force);
    float2 force_direction = force_magnitude > 0.0001f ? normalize(nodes[id.x].force) : float2(0, 0);
    
    // Scale arrow length based on force magnitude, but keep it visible
    float visible_scale = 0.5; // Adjust this to control the overall arrow size
    float min_length = 0.2;
    float max_length = 2.0;
    float arrow_length = clamp(log(1 + force_magnitude) * visible_scale, min_length, max_length);
    
    // Calculate arrow endpoint
    float2 arrow_end = nodes[id.x].position + force_direction * arrow_length;
    
    // Store arrow data
    force_arrows[id.x].start = nodes[id.x].position;
    force_arrows[id.x].end = arrow_end;
    force_arrows[id.x].strength = force_magnitude;
}