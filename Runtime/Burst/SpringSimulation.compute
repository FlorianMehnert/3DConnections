#pragma kernel SpringForces
#pragma kernel CollisionResponse
#pragma kernel IntegrateForces

struct NodeData
{
    float2 position;
    float2 velocity;
    float2 force;
    int nodeType;
};



RWStructuredBuffer<NodeData> nodes;
uint nodeCount;
float deltaTime;
float stiffness;
float damping;
float colliderRadius;
float collisionResponseStrength;

float goRestLength;
float gcRestLength;
float ccRestLength;



[numthreads(64,1,1)]
void SpringForces (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= nodeCount) return;
    
    // Reset force for this node
    nodes[id.x].force = float2(0, 0);
    
    for (uint j = 0; j < nodeCount; j++)
    {
        if (id.x == j) continue;
        
        // Calculate displacement between nodes
        float2 displacement = nodes[j].position - nodes[id.x].position;
        float distance = length(displacement);
        
        if (distance < 0.0001f) continue; // Avoid division by zero
        
        // Direction of the force
        float2 direction = displacement / distance;
        
        // Determine interaction stiffness and rest length based on node types
        float nodeStiffness = stiffness;
        float restLength = 1.0; // Default rest length
        
        if (nodes[id.x].nodeType == 0 && nodes[j].nodeType == 0) 
        {
            // GameObject - GameObject
            nodeStiffness = stiffness * .1;
            restLength = goRestLength;
        }
        else if ((nodes[id.x].nodeType == 0 && nodes[j].nodeType == 1) ||
                (nodes[id.x].nodeType == 1 && nodes[j].nodeType == 0)) 
        {
            // GameObject - Component
            nodeStiffness = stiffness * 5.0;
            restLength = gcRestLength;
        }
        else {
            // Component - Component
            restLength = ccRestLength;
        }
        
        // Calculate spring force with rest length
        // F = -k * (|x| - L) * (x/|x|) where L is rest length
        float springMagnitude = nodeStiffness * (distance - restLength);
        float2 springForce = direction * springMagnitude;
        
        // Apply the spring force
        nodes[id.x].force += springForce;
    }
    
    // Apply damping force
    float2 dampingForce = -damping * nodes[id.x].velocity;
    nodes[id.x].force += dampingForce;
}

[numthreads(64,1,1)]
void CollisionResponse (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= nodeCount) return;
    
    float2 position = nodes[id.x].position;
    float2 velocity = nodes[id.x].velocity;
    
    for (int j = 0; (uint)j < nodeCount; j++)
    {
        if (id.x == (uint)j) continue;
        
        float2 delta = position - nodes[j].position;
        float distance = length(delta);
        float minDist = colliderRadius * 2;
        
        if (distance < minDist && distance > 0.0001f)
        {
            float2 direction = delta / distance;
            float overlap = minDist - distance;
            
            position += direction * (overlap * 0.5f);
            
            float2 relativeVelocity = velocity - nodes[j].velocity;
            float velocityAlongNormal = dot(relativeVelocity, direction);
            
            if (velocityAlongNormal < 0)
            {
                float restitution = 0.5f;
                float j_scalar = -(1 + restitution) * velocityAlongNormal;
                j_scalar *= collisionResponseStrength;
                
                velocity += direction * j_scalar;
            }
        }
    }
    
    nodes[id.x].position = position;
    nodes[id.x].velocity = velocity;
}

[numthreads(64,1,1)]
void IntegrateForces (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= nodeCount) return;
    
    // Semi-implicit Euler integration
    nodes[id.x].velocity += nodes[id.x].force * deltaTime;
    nodes[id.x].position += nodes[id.x].velocity * deltaTime;
}