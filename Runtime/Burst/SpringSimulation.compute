#pragma kernel SpringForces
#pragma kernel CollisionResponse
#pragma kernel IntegrateForces

struct NodeData
{
    float2 position;
    float2 velocity;
    float2 force;
    int nodeType;
};

RWStructuredBuffer<NodeData> nodes;
uint nodeCount;
float deltaTime;
float stiffness;
float damping;
float colliderRadius;
float collisionResponseStrength;

// Relaxation parameters
float relaxationFactor; // Will be < 1 during relaxation and 1 when fully relaxed
float maxVelocityLimit; // Will increase over time during relaxation

float goRestLength;
float gcRestLength;
float ccRestLength;

[numthreads(64,1,1)]
void SpringForces (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= nodeCount) return;
    
    // Reset force for this node
    nodes[id.x].force = float2(0, 0);
    
    for (uint j = 0; j < nodeCount; j++)
    {
        if (id.x == j) continue;
        
        // Calculate displacement between nodes
        float2 displacement = nodes[j].position - nodes[id.x].position;
        float distance = length(displacement);
        
        if (distance < 0.0001f) continue; // Avoid division by zero
        
        // Direction of the force
        float2 direction = displacement / distance;
        
        // Determine interaction stiffness and rest length based on node types
        float nodeStiffness = stiffness * relaxationFactor; // Apply relaxation factor to stiffness
        float restLength = 1.0; // Default rest length
        
        if (nodes[id.x].nodeType == 0 && nodes[j].nodeType == 0) 
        {
            // GameObject - GameObject
            nodeStiffness = stiffness * .1 * relaxationFactor;
            restLength = goRestLength;
        }
        else if ((nodes[id.x].nodeType == 0 && nodes[j].nodeType == 1) ||
                (nodes[id.x].nodeType == 1 && nodes[j].nodeType == 0)) 
        {
            // GameObject - Component
            nodeStiffness = stiffness * 5.0 * relaxationFactor;
            restLength = gcRestLength;
        }
        else {
            // Component - Component
            restLength = ccRestLength;
        }
        
        // Calculate spring force with rest length
        // F = -k * (|x| - L) * (x/|x|) where L is rest length
        float springMagnitude = nodeStiffness * (distance - restLength);
        float2 springForce = direction * springMagnitude;
        
        // Apply the spring force
        nodes[id.x].force += springForce;
    }
    
    // Apply damping force - increase damping during relaxation phase
    float effectiveDamping = damping * (2.0 - relaxationFactor); // More damping when relaxationFactor is low
    float2 dampingForce = -effectiveDamping * nodes[id.x].velocity;
    nodes[id.x].force += dampingForce;

    // Add a weak centering force
    float2 centerPosition = float2(0, 0);
    for (uint j = 0; j < nodeCount; j++) {
        centerPosition += nodes[j].position;
    }
    centerPosition /= nodeCount;
    
    float2 toCenterDir = centerPosition - nodes[id.x].position;
    float centerDist = length(toCenterDir);
    
    if (centerDist > 0.001) {
        // Increase centering force during relaxation
        float stabilizingForce = 1e-6 * (1.0 + (2.0 - relaxationFactor) * 10.0); 
        nodes[id.x].force += normalize(toCenterDir) * stabilizingForce * centerDist;
    }
}

[numthreads(64,1,1)]
void CollisionResponse (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= nodeCount) return;
    
    float2 position = nodes[id.x].position;
    float2 velocity = nodes[id.x].velocity;
    
    for (int j = 0; (uint)j < nodeCount; j++)
    {
        if (id.x == (uint)j) continue;
        
        float2 delta = position - nodes[j].position;
        float distance = length(delta);
        float minDist = colliderRadius * 2;
        
        if (distance < minDist && distance > 0.0001f)
        {
            float2 direction = delta / distance;
            float overlap = minDist - distance;
            
            // Increase positional correction during relaxation
            float correctionStrength = 0.5f * relaxationFactor + 0.5f;
            position += direction * (overlap * correctionStrength);
            
            float2 relativeVelocity = velocity - nodes[j].velocity;
            float velocityAlongNormal = dot(relativeVelocity, direction);
            
            if (velocityAlongNormal < 0)
            {
                // Adjust restitution based on relaxation
                float restitution = 0.5f * relaxationFactor;
                float j_scalar = -(1 + restitution) * velocityAlongNormal;
                j_scalar *= collisionResponseStrength * relaxationFactor;
                
                velocity += direction * j_scalar;
            }
        }
    }
    
    nodes[id.x].position = position;
    nodes[id.x].velocity = velocity;

    if (nodeCount > 1) {
        // Calculate center of mass
        float2 centerOfMass = float2(0, 0);
        for (uint j = 0; j < nodeCount; j++) {
            centerOfMass += nodes[j].position;
        }
        centerOfMass /= nodeCount;
        
        // Calculate radial vector
        float2 radialVector = nodes[id.x].position - centerOfMass;
        float distance = length(radialVector);
        
        if (distance > 0.001) {
            // Calculate tangential velocity component
            float2 direction = radialVector / distance;
            float2 tangent = float2(-direction.y, direction.x);
            float tangentialVelocity = dot(nodes[id.x].velocity, tangent);
            
            // Increase angular damping during relaxation
            float angularDamping = 0.05 * (2.0 - relaxationFactor);
            nodes[id.x].velocity -= tangent * tangentialVelocity * angularDamping;
        }
    }
}

[numthreads(64,1,1)]
void IntegrateForces (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= nodeCount) return;
    
    // Use a smaller effective timestep for stability
    float effectiveDeltaTime = min(deltaTime, 0.01); // Cap at 10ms
    
    // Semi-implicit Euler integration
    nodes[id.x].velocity += nodes[id.x].force * effectiveDeltaTime;
    
    // Apply extra damping during relaxation
    float extraDamping = 0.99 * relaxationFactor + 0.9 * (1.0 - relaxationFactor);
    nodes[id.x].velocity *= extraDamping;
    
    // Apply velocity limit - more strict during relaxation
    float currentSpeed = length(nodes[id.x].velocity);
    if (currentSpeed > maxVelocityLimit) {
        nodes[id.x].velocity = (nodes[id.x].velocity / currentSpeed) * maxVelocityLimit;
    }
    
    nodes[id.x].position += nodes[id.x].velocity * effectiveDeltaTime;
}