namespace _3DConnections.Runtime.Managers
{
    using System;
    using System.Collections.Generic;
    using JetBrains.Annotations;
    using SimpleJSON;
    using TMPro;
    using UnityEngine;
    using Object = UnityEngine.Object;
    using ScriptableObjectInventory;
    using Nodes.Extensions;
    using cols = ScriptableObjects.NodeColorsScriptableObject;


#if UNITY_EDITOR
    using UnityEditor;
#endif

    using Nodes;

    public partial class SceneAnalyzer
    {
        private static string GetClassNameFromMetric(string metricName)
        {
            // Split the metric name to extract the class name (e.g., "Program.cs::AnalyzeCodeMetrics" -> "Program")
            var parts = metricName.Split(new[] { "::" }, StringSplitOptions.None);
            return parts.Length > 0
                ? parts[0].Split('.')[0]
                : // Extract "Program" from "Program.cs"
                metricName; // Fallback in case of unexpected format
        }

        /// <summary>
        /// Function to load metrics generated by external roslyn script which analyzes code complexity and maintainability  
        /// </summary>
        /// <param name="json"></param>
        private void LoadComplexityMetrics(string json)
        {
            var root = JSON.Parse(json);
            _complexityMap = new Dictionary<string, float>();

            foreach (var metricNode in root["Metrics"].AsArray)
            {
                var maintainability = metricNode.Value["Maintainability"].AsFloat;
                string metricName = metricNode.Value["Name"];
                var className = GetClassNameFromMetric(metricName);

                _complexityMap.TryAdd(className, maintainability);
            }
        }

        /// <summary>
        /// Enhanced GetOrSpawnNode that can handle virtual component nodes
        /// </summary>
        /// <param name="obj">The Unity Object to create a node for (can be null for virtual nodes)</param>
        /// <param name="depth">The depth in the hierarchy</param>
        /// <param name="parentNodeObject">The parent node to connect to</param>
        /// <param name="isAsset">Whether this represents an asset reference</param>
        /// <param name="virtualComponentType">If provided, creates a virtual node for this component type</param>
        /// <returns>The spawned or existing node GameObject</returns>
        private GameObject GetOrSpawnNode(Object obj, int depth, GameObject parentNodeObject = null,
    bool isAsset = false, Type virtualComponentType = null)
{
    // Handle virtual component nodes
    if (virtualComponentType != null)
    {
        // First, check if there's already a real component node of this type
        var existingComponentNode = FindNodeByComponentType(virtualComponentType);
        if (existingComponentNode)
        {
            // Connect to existing real component node instead of creating virtual one
            if (!parentNodeObject) return existingComponentNode;
            var connectionColor = cols.DimColor(cols.DynamicComponentConnection, 0.7f);
            parentNodeObject.ConnectNodes(existingComponentNode, connectionColor, depth,
                "dynamicComponentConnection", cols.MaxWidthHierarchy);
            return existingComponentNode;
        }

        var fakeInstanceId = -virtualComponentType.GetHashCode();

        // Check if a virtual node already exists
        if (_instanceIdToNodeLookup.TryGetValue(fakeInstanceId, out var existingVirtualNode))
        {
            // Ensure the existing virtual node is still valid
            if (existingVirtualNode)
            {
                if (!parentNodeObject) return existingVirtualNode;
                var connectionColor = cols.DimColor(cols.DynamicComponentConnection, 0.7f);
                parentNodeObject.ConnectNodes(existingVirtualNode, connectionColor, depth,
                    "dynamicComponentConnection", cols.MaxWidthHierarchy);
                return existingVirtualNode;
            }

            // Remove invalid entry
            _instanceIdToNodeLookup.Remove(fakeInstanceId);
        }

        // Only create virtual node if no real or virtual node exists
        var virtualNode = SpawnNode(null, false, virtualComponentType);
        if (!virtualNode) return virtualNode;
        {
            // Connect to parent if provided
            if (!parentNodeObject) return virtualNode;
            var connectionColor = cols.DimColor(cols.DynamicComponentConnection, 0.7f);
            parentNodeObject.ConnectNodes(virtualNode, connectionColor, depth,
                "dynamicComponentConnection", cols.MaxWidthHierarchy);
        }
        return virtualNode;
    }

    if (!obj) return null;

    var instanceId = obj.GetInstanceID();

    // Check if this node already exists
    if (_instanceIdToNodeLookup.TryGetValue(instanceId, out var existingNode))
    {
        if (!existingNode)
        {
            _instanceIdToNodeLookup.Remove(instanceId);
        }
        else
        {
            if (parentNodeObject == null) return existingNode;
            var connectionColor = isAsset ? 
                new Color(cols.ReferenceConnection.r, cols.ReferenceConnection.g, cols.ReferenceConnection.b, 0.5f) :
                obj switch
                {
                    GameObject => new Color(cols.ParentChildConnection.r, cols.ParentChildConnection.g, cols.ParentChildConnection.b, 0.5f),
                    Component => new Color(cols.ComponentConnection.r, cols.ComponentConnection.g, cols.ComponentConnection.b, 0.5f),
                    _ => new Color(cols.ReferenceConnection.r, cols.ReferenceConnection.g, cols.ReferenceConnection.b, 0.5f)
                };

            var connectionType = isAsset ? "referenceConnection" : obj switch
            {
                GameObject => "parentChildConnection",
                Component => "componentConnection",
                _ => "referenceConnection"
            };

            parentNodeObject.ConnectNodes(existingNode, connectionColor, depth, connectionType, cols.MaxWidthHierarchy);
            return existingNode;
        }
    }

    var newNode = SpawnNode(obj, isAsset);
    if (newNode == null || parentNodeObject == null) return newNode;
    {
        var connectionColor = isAsset ? 
            new Color(cols.ReferenceConnection.r, cols.ReferenceConnection.g, cols.ReferenceConnection.b, 0.5f) :
            obj switch
            {
                GameObject => new Color(cols.ParentChildConnection.r, cols.ParentChildConnection.g, cols.ParentChildConnection.b, 0.5f),
                Component => new Color(cols.ComponentConnection.r, cols.ComponentConnection.g, cols.ComponentConnection.b, 0.5f),
                _ => new Color(cols.ReferenceConnection.r, cols.ReferenceConnection.g, cols.ReferenceConnection.b, 0.5f)
            };

        var connectionType = isAsset ? "referenceConnection" : obj switch
        {
            GameObject => "parentChildConnection",
            Component => "componentConnection",
            _ => "referenceConnection"
        };

        parentNodeObject.ConnectNodes(newNode, connectionColor, depth, connectionType, cols.MaxWidthHierarchy);
    }

    return newNode;
}

        /// <summary>
        /// Find existing node by component type
        /// </summary>
        /// <param name="componentType"></param>
        /// <returns></returns>
        /// <summary>
        /// Find existing node by component type (including virtual nodes)
        /// </summary>
        private GameObject FindNodeByComponentType(Type componentType)
        {
            foreach (var kvp in _instanceIdToNodeLookup)
            {
                var nodeObject = kvp.Value;
                if (!nodeObject) continue;
        
                var nodeType = nodeObject.GetComponent<NodeType>();
                if (nodeType?.reference is Component comp && comp.GetType() == componentType)
                    //|| nodeType?.reference == null && 
                    //!string.IsNullOrEmpty(nodeObject.name) && 
                    // nodeObject.name == $"virtual_co_{componentType.Name}")
                {
                    return nodeObject;
                }
            }

            return null;
        }
        
        /// <summary>
        /// Find existing node by multiple criteria
        /// </summary>
        private GameObject FindExistingNode(Type componentType, Object reference = null)
        {
            // First priority: exact reference match
            if (reference != null)
            {
                var instanceId = reference.GetInstanceID();
                if (_instanceIdToNodeLookup.TryGetValue(instanceId, out var exactNode))
                {
                    return exactNode;
                }
            }
    
            // Second priority: component type match
            if (componentType != null)
            {
                return FindNodeByComponentType(componentType);
            }
    
            return null;
        }


        /// <summary>
        /// Spawn a node gameObject in the overlay scene.
        /// If "virtualType" is provided, a virtual node representing that component type is created.
        /// </summary>
        /// <param name="obj">The object to represent; for virtual nodes this is null.</param>
        /// <param name="isAsset">Mark as an asset if needed.</param>
        /// <param name="virtualType">If non-null, indicates that a virtual node should be created for the given component type.</param>
        /// <returns>The spawned node GameObject.</returns>
        private GameObject SpawnNode(Object obj, bool isAsset = false, Type virtualType = null)
        {
            var nodeObject = CreateNodeInstance();
            if (!nodeObject)
                return null;

            ConfigureNodeType(nodeObject, obj, virtualType);
            AddTextChild(nodeObject, obj, virtualType);

#if UNITY_EDITOR
            // Only add an icon for non-virtual nodes.
            if (virtualType == null)
                AddIcon(nodeObject, obj);
#endif

            ConfigureNodeName(nodeObject, obj, virtualType);
            ApplyNodeColor(nodeObject, obj, isAsset, virtualType);

            // Ensure the node is properly registered in the graph system
            if (virtualType != null)
            {
                var fakeInstanceId = -(virtualType.GetHashCode());
                _instanceIdToNodeLookup[fakeInstanceId] = nodeObject;
            }
            else if (obj != null)
            {
                _instanceIdToNodeLookup[obj.GetInstanceID()] = nodeObject;
            }

            // Add to AllNodes collection for layout processing
            if (ScriptableObjectInventory.Instance.graph?.AllNodes != null)
            {
                ScriptableObjectInventory.Instance.graph.AllNodes.Add(nodeObject);
            }

            return nodeObject;
        }


        /// <summary>
        /// Creates a new node instance using the prefab and ensures the parent and camera are valid.
        /// </summary>
        private GameObject CreateNodeInstance()
        {
            if (!ScriptableObjectInventory.Instance.overlay.GetCameraOfScene())
            {
                Debug.Log("No camera while trying to spawn a node in NodeBuilder");
                return null;
            }

            if (!parentNode)
            {
                parentNode = ScriptableObjectInventory.Instance.overlay.GetNodeGraph();
                if (!parentNode)
                    Debug.Log("Node graph game object was not found");
            }

            GameObject nodeObject = Instantiate(nodePrefab, parentNode.transform);
            _currentNodes++;
            nodeObject.transform.localPosition = Vector3.zero;
            nodeObject.transform.localScale = new Vector3(nodeWidth, nodeHeight, 1f);

            // integrate new version of nodes using sprite renderers
            var spriteRenderer = nodeObject.GetComponent<SpriteRenderer>();
            if (spriteRenderer && spriteRenderer.sprite)
            {
                var sprite = spriteRenderer.sprite;
                var spriteSize = sprite.rect.size / sprite.pixelsPerUnit;
                nodeObject.transform.localScale = new Vector3(
                    nodeWidth / spriteSize.x,
                    nodeHeight / spriteSize.y,
                    1f
                );
            }

            nodeObject.layer = LayerMask.NameToLayer("OverlayScene");
            return nodeObject;
        }

        /// <summary>
        /// Configures the NodeType component on the node.
        /// For a virtual node - which is used for either Event/Dynamic reference (when virtualType is not null),
        /// the node is marked as a component node with no reference.
        /// Otherwise, it is assigned based on the supplied object.
        /// </summary>
        private static void ConfigureNodeType(GameObject nodeObject, Object obj, Type virtualType)
        {
            var nodeType = nodeObject.GetComponent<NodeType>();
            if (!nodeType) return;
            if (virtualType != null)
            {
                nodeType.reference = null;
                nodeType.nodeTypeName = NodeTypeName.Component;
            }
            else
            {
                nodeType.SetNodeType(obj);
                nodeType.reference = obj;
            }
        }

        /// <summary>
        /// Adds a Text child (using TextMeshPro) to display a label on the node.
        /// For a virtual node the text is set to the type name (in parentheses).
        /// </summary>
        private static void AddTextChild(GameObject nodeObject, Object obj, Type virtualType)
        {
            var textObj = new GameObject("Text");
            textObj.transform.SetParent(nodeObject.transform);
            textObj.transform.localPosition = new Vector3(0, 0.6f, -1f);

            var text = textObj.AddComponent<TextMeshPro>();

            if (virtualType != null)
            {
                text.text = $"({virtualType.Name})";
            }
            else if (obj is Component component)
            {
                // For components, show both the GameObject name and Component type
                text.text = $"{component.gameObject.name}.{component.GetType().Name}";
            }
            else
            {
                text.text = obj ? obj.name : "null object";
            }

            text.alignment = TextAlignmentOptions.Center;
            text.fontSize = 1.5f;
        }


#if UNITY_EDITOR
        /// <summary>
        /// Adds an Icon child to the node when appropriate.
        /// Only non-virtual nodes (and when setIcons is enabled) will configure an icon.
        /// </summary>
        private void AddIcon(GameObject nodeObject, Object obj)
        {
            if (obj is not Component componentObject || !setIcons) return;
            var componentIcon = EditorGUIUtility.ObjectContent(null, componentObject.GetType()).image as Texture2D;
            if (!componentIcon) return;
            var iconObj = new GameObject("Icon");
            iconObj.transform.SetParent(nodeObject.transform);
            iconObj.transform.localPosition = new Vector3(0, 0, -1f);

            SpriteRenderer iconRenderer = iconObj.AddComponent<SpriteRenderer>();
            var sprite = TextureToSprite(componentIcon);
            iconRenderer.sprite = sprite;
            iconRenderer.sortingOrder = 1;

            const float desiredHeight = 0.5f;
            Vector2 spriteSize = sprite.bounds.size;
            float scaleY = desiredHeight / spriteSize.y;
            float scaleX = scaleY * (spriteSize.x / spriteSize.y) * 0.5f; // nodes are scale 2:1
            iconObj.transform.localScale = new Vector3(scaleX, scaleY, 1);
        }
#endif
        /// <summary>
        /// Configures the node's name based on its type and reference.
        /// For virtual nodes the name is prefixed with "virtual_co_" and the type name.
        /// </summary>
        private void ConfigureNodeName(GameObject nodeObject, Object obj, Type virtualType)
        {
            var nodeType = nodeObject.GetComponent<NodeType>();
            if (virtualType != null)
            {
                nodeObject.name = $"virtual_co_{virtualType.Name}";
            }
            else
            {
                var prefixNode = "";
                if (nodeType == null) return;
                prefixNode = nodeType.nodeTypeName switch
                {
                    NodeTypeName.GameObject => "go_",
                    NodeTypeName.Component => "co_",
                    NodeTypeName.ScriptableObject => "so_",
                    _ => prefixNode
                };

                // If no reference, this is the root
                if (nodeType.reference == null)
                {
                    nodeObject.name = "tfRoot";
                    nodeType.nodeTypeName = NodeTypeName.GameObject;
                }
                else
                {
                    string postfixNode = prefixNode != "go_" ? "_" + nodeType.reference.GetType().Name : string.Empty;
                    nodeObject.name = $"{prefixNode}{obj.name}{postfixNode}";
                }
            }
        }

        /// <summary>
        /// Applies colors to the node. For virtual nodes the node color is set using a dimmed version of the component color;
        /// for a normal object the node is colored based on whether it is a prefab or not.
        /// </summary>
        private void ApplyNodeColor(GameObject nodeObject, Object obj, bool isAsset, Type virtualType)
        {
            if (virtualType != null)
            {
                // Use a dimmed version of the component color to denote a virtual node.
                Color dimmedColor = cols.DynamicComponentConnection;
                nodeObject.SetNodeColor(obj, cols.GameObjectColor, dimmedColor, cols.ScriptableObjectColor,
                    cols.AssetColor,
                    overrideColor: dimmedColor);
            }
            else
            {
                nodeObject.SetNodeColor(obj, cols.GameObjectColor, cols.ComponentColor, cols.ScriptableObjectColor,
                    cols.AssetColor,
                    isAsset);
            }
        }

        [UsedImplicitly]
        private static Sprite TextureToSprite(Texture2D texture)
        {
            return Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f), 100f);
        }
    }
}