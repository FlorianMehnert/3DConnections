namespace _3DConnections.Runtime.Managers
{
    using ScriptableObjectInventory;
    using System;
    using System.Collections.Generic;
    using JetBrains.Annotations;
    using SimpleJSON;
    using TMPro;
    using UnityEngine;
    using Object = UnityEngine.Object;

#if UNITY_EDITOR
    using UnityEditor;
#endif
    
    using Nodes;

    public partial class SceneAnalyzer
    {
        private static string GetClassNameFromMetric(string metricName)
        {
            // Split the metric name to extract the class name (e.g., "Program.cs::AnalyzeCodeMetrics" -> "Program")
            var parts = metricName.Split(new[] { "::" }, StringSplitOptions.None);
            return parts.Length > 0
                ? parts[0].Split('.')[0]
                : // Extract "Program" from "Program.cs"
                metricName; // Fallback in case of unexpected format
        }

        /// <summary>
        /// Function to load metrics generated by external roslyn script which analyzes code complexity and maintainability  
        /// </summary>
        /// <param name="json"></param>
        private void LoadComplexityMetrics(string json)
        {
            var root = JSON.Parse(json);
            _complexityMap = new Dictionary<string, float>();

            foreach (var metricNode in root["Metrics"].AsArray)
            {
                var maintainability = metricNode.Value["Maintainability"].AsFloat;
                string metricName = metricNode.Value["Name"];
                var className = GetClassNameFromMetric(metricName);

                _complexityMap.TryAdd(className, maintainability);
            }
        }

        private GameObject GetOrSpawnNode(Object obj, int depth, GameObject parentNodeObject = null,
            bool isAsset = false)
        {
            if (!obj) return null;

            var instanceId = obj.GetInstanceID();

            // Check if this node already exists
            if (_instanceIdToNodeLookup.TryGetValue(instanceId, out var existingNode))
            {
                // Connect existing node
                if (!parentNodeObject) return existingNode;
                if (isAsset)
                    parentNodeObject.ConnectNodes(existingNode,
                        new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f), depth + 1,
                        "referenceConnection", ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);
                else
                    parentNodeObject.ConnectNodes(existingNode,
                        obj switch
                        {
                            GameObject => new Color(parentChildConnection.r, parentChildConnection.g,
                                parentChildConnection.b, 0.5f),
                            Component => new Color(componentConnection.r, componentConnection.g, componentConnection.b,
                                0.5f),
                            _ => new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f)
                        }, depth, obj switch
                        {
                            GameObject => "parentChildConnection",
                            Component => "componentConnection",
                            _ => "referenceConnection"
                        }, ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);

                return existingNode;
            }

            // Create a new node
            var newNode = SpawnNode(obj, isAsset);
            _instanceIdToNodeLookup[instanceId] = newNode;
            if (!parentNodeObject) return newNode;
            if (isAsset)
                parentNodeObject.ConnectNodes(newNode,
                    new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f), depth + 1,
                    "referenceConnection", ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);
            else
                parentNodeObject.ConnectNodes(newNode,
                    obj switch
                    {
                        GameObject => new Color(parentChildConnection.r, parentChildConnection.g,
                            parentChildConnection.b, 0.5f),
                        Component => new Color(componentConnection.r, componentConnection.g, componentConnection.b,
                            0.5f),
                        _ => new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f)
                    }, depth, obj switch
                    {
                        GameObject => "parentChildConnection",
                        Component => "componentConnection",
                        _ => "referenceConnection"
                    }, ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);

            return newNode;
        }

        /// <summary>
        /// Find existing node by component type
        /// </summary>
        /// <param name="componentType"></param>
        /// <returns></returns>
        private GameObject FindNodeByComponentType(Type componentType)
        {
            foreach (var kvp in _instanceIdToNodeLookup)
            {
                var nodeType = kvp.Value.GetComponent<NodeType>();
                if (nodeType?.reference is Component comp && comp.GetType() == componentType)
                {
                    return kvp.Value;
                }
            }

            return null;
        }

        /// <summary>
        /// Find an existing node or create a new one for the component type
        /// </summary>
        /// <param name="componentType"></param>
        /// <returns></returns>
        private GameObject FindOrCreateNodeForComponentType(Type componentType)
        {
            var existingNode = FindNodeByComponentType(componentType);
            return existingNode ? existingNode : SpawnNode(null, false, componentType);
        }

        /// <summary>
        /// Spawn a node gameObject in the overlay scene.
        /// If "virtualType" is provided, a virtual node representing that component type is created.
        /// </summary>
        /// <param name="obj">The object to represent; for virtual nodes this is null.</param>
        /// <param name="isAsset">Mark as an asset if needed.</param>
        /// <param name="virtualType">If non-null, indicates that a virtual node should be created for the given component type.</param>
        /// <returns>The spawned node GameObject.</returns>
        private GameObject SpawnNode(Object obj, bool isAsset = false, Type virtualType = null)
        {
            GameObject nodeObject = CreateNodeInstance();
            if (nodeObject == null)
                return null;

            ConfigureNodeType(nodeObject, obj, virtualType);
            AddArtificialGameObjectComponent(nodeObject);
            AddTextChild(nodeObject, obj, virtualType);

#if UNITY_EDITOR
            // Only add an icon for non-virtual nodes.
            if (virtualType == null)
                AddIcon(nodeObject, obj);
#endif

            ConfigureNodeName(nodeObject, obj, virtualType);
            ApplyNodeColor(nodeObject, obj, isAsset, virtualType);

            // For virtual nodes, store the node using a fake negative instance ID.
            if (virtualType == null) return nodeObject;
            int fakeInstanceId = -(virtualType.GetHashCode());

            // Add the virtual node immediately to all nodes.
            _instanceIdToNodeLookup[fakeInstanceId] = nodeObject;
            if (ScriptableObjectInventory.Instance.graph.AllNodes is { Count: > 0 } && nodeObject)
                ScriptableObjectInventory.Instance.graph.AllNodes.Add(nodeObject);

            return nodeObject;
        }

        /// <summary>
        /// Creates a new node instance using the prefab and ensures the parent and camera are valid.
        /// </summary>
        private GameObject CreateNodeInstance()
        {
            if (!ScriptableObjectInventory.Instance.overlay.GetCameraOfScene())
            {
                Debug.Log("No camera while trying to spawn a node in NodeBuilder");
                return null;
            }

            if (!parentNode)
            {
                parentNode = ScriptableObjectInventory.Instance.overlay.GetNodeGraph();
                if (!parentNode)
                    Debug.Log("Node graph game object was not found");
            }

            GameObject nodeObject = Instantiate(nodePrefab, parentNode.transform);
            _currentNodes++;
            nodeObject.transform.localPosition = Vector3.zero;
            nodeObject.transform.localScale = new Vector3(nodeWidth, nodeHeight, 1f);
            nodeObject.layer = LayerMask.NameToLayer("OverlayScene");
            return nodeObject;
        }

        /// <summary>
        /// Configures the NodeType component on the node.
        /// For a virtual node - which is used for either Event/Dynamic reference (when virtualType is not null),
        /// the node is marked as a component node with no reference.
        /// Otherwise, it is assigned based on the supplied object.
        /// </summary>
        private static void ConfigureNodeType(GameObject nodeObject, Object obj, Type virtualType)
        {
            var nodeType = nodeObject.GetComponent<NodeType>();
            if (!nodeType) return;
            if (virtualType != null)
            {
                nodeType.reference = null;
                nodeType.nodeTypeName = NodeTypeName.Component;
            }
            else
            {
                nodeType.SetNodeType(obj);
                nodeType.reference = obj;
            }
        }

        /// <summary>
        /// Adds the ArtificialGameObject component to prevent recursive spawns on analyzing the overlay scene itself.
        /// </summary>
        private static void AddArtificialGameObjectComponent(GameObject nodeObject)
        {
            nodeObject.AddComponent<ArtificialGameObject>();
        }

        /// <summary>
        /// Adds a Text child (using TextMeshPro) to display a label on the node.
        /// For a virtual node the text is set to the type name (in parentheses).
        /// </summary>
        private static void AddTextChild(GameObject nodeObject, Object obj, Type virtualType)
        {
            var textObj = new GameObject("Text");
            textObj.transform.SetParent(nodeObject.transform);
            textObj.transform.localPosition = new Vector3(0, 0.6f, -1f);

            var text = textObj.AddComponent<TextMeshPro>();
            if (virtualType != null)
            {
                text.text = $"({virtualType.Name})";
            }
            else
            {
                text.text = obj ? obj.name : "null object";
            }

            text.alignment = TextAlignmentOptions.Center;
            text.fontSize = 1.5f;
        }

#if UNITY_EDITOR
        /// <summary>
        /// Adds an Icon child to the node when appropriate.
        /// Only non-virtual nodes (and when setIcons is enabled) will configure an icon.
        /// </summary>
        private void AddIcon(GameObject nodeObject, Object obj)
        {
            if (obj is not Component componentObject || !setIcons) return;
            var componentIcon = EditorGUIUtility.ObjectContent(null, componentObject.GetType()).image as Texture2D;
            if (!componentIcon) return;
            var iconObj = new GameObject("Icon");
            iconObj.transform.SetParent(nodeObject.transform);
            iconObj.transform.localPosition = new Vector3(0, 0, -1f);

            SpriteRenderer iconRenderer = iconObj.AddComponent<SpriteRenderer>();
            var sprite = TextureToSprite(componentIcon);
            iconRenderer.sprite = sprite;
            iconRenderer.sortingOrder = 1;

            const float desiredHeight = 0.5f;
            Vector2 spriteSize = sprite.bounds.size;
            float scaleY = desiredHeight / spriteSize.y;
            float scaleX = scaleY * (spriteSize.x / spriteSize.y) * 0.5f; // nodes are scale 2:1
            iconObj.transform.localScale = new Vector3(scaleX, scaleY, 1);
        }
#endif
        /// <summary>
        /// Configures the node's name based on its type and reference.
        /// For virtual nodes the name is prefixed with "virtual_co_" and the type name.
        /// </summary>
        private void ConfigureNodeName(GameObject nodeObject, Object obj, Type virtualType)
        {
            var nodeType = nodeObject.GetComponent<NodeType>();
            if (virtualType != null)
            {
                nodeObject.name = $"virtual_co_{virtualType.Name}";
            }
            else
            {
                var prefixNode = "";
                if (nodeType == null) return;
                prefixNode = nodeType.nodeTypeName switch
                {
                    NodeTypeName.GameObject => "go_",
                    NodeTypeName.Component => "co_",
                    NodeTypeName.ScriptableObject => "so_",
                    _ => prefixNode
                };

                // If no reference, this is the root
                if (nodeType.reference == null)
                {
                    nodeObject.name = "tfRoot";
                    nodeType.nodeTypeName = NodeTypeName.GameObject;
                }
                else
                {
                    string postfixNode = prefixNode != "go_" ? "_" + nodeType.reference.GetType().Name : string.Empty;
                    nodeObject.name = $"{prefixNode}{obj.name}{postfixNode}";
                }
            }
        }

        /// <summary>
        /// Applies colors to the node. For virtual nodes the node color is set using a dimmed version of the component color;
        /// for a normal object the node is colored based on whether it is a prefab or not.
        /// </summary>
        private void ApplyNodeColor(GameObject nodeObject, Object obj, bool isAsset, Type virtualType)
        {
            if (virtualType != null)
            {
                // Use a dimmed version of the component color to denote a virtual node.
                Color dimmedColor = dynamicComponentConnection;
                nodeObject.SetNodeColor(obj, gameObjectColor, dimmedColor, scriptableObjectColor, assetColor,
                    overrideColor: dimmedColor);
            }
            else
            {
                if (!IsPrefab(obj))
                {
                    nodeObject.SetNodeColor(obj, gameObjectColor, componentColor, scriptableObjectColor, assetColor,
                        isAsset);
                }
                else
                {
                    // For prefabs, enable an emission effect.
                    var nodeRenderer = nodeObject.GetComponent<Renderer>();
                    if (!nodeRenderer) return;
                    nodeRenderer.material.EnableKeyword("_EMISSION");
                    Color emissionColor = Color.HSVToRGB(0.1f, 1f, 1f) * 5.0f; // White with intensity
                    nodeRenderer.material.SetColor(EmissionColor, emissionColor);
                }
            }
        }

        [UsedImplicitly]
        private static Sprite TextureToSprite(Texture2D texture)
        {
            return Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f), 100f);
        }
    }
}