using System;
using System.Collections.Generic;
using JetBrains.Annotations;
using SimpleJSON;
using TMPro;
using UnityEngine;
using Object = UnityEngine.Object;

#if UNITY_EDITOR
using UnityEditor;
#endif

public partial class SceneAnalyzer
{
    private static string GetClassNameFromMetric(string metricName)
    {
        // Split the metric name to extract the class name (e.g., "Program.cs::AnalyzeCodeMetrics" -> "Program")
        var parts = metricName.Split(new[] { "::" }, StringSplitOptions.None);
        return parts.Length > 0
            ? parts[0].Split('.')[0]
            : // Extract "Program" from "Program.cs"
            metricName; // Fallback in case of unexpected format
    }

    /// <summary>
    /// Function to load metrics generated by external roslyn script which analyzes code complexity and maintainability  
    /// </summary>
    /// <param name="json"></param>
    private void LoadComplexityMetrics(string json)
    {
        var root = JSON.Parse(json);
        _complexityMap = new Dictionary<string, float>();

        foreach (var metricNode in root["Metrics"].AsArray)
        {
            var maintainability = metricNode.Value["Maintainability"].AsFloat;
            string metricName = metricNode.Value["Name"];
            var className = GetClassNameFromMetric(metricName);

            _complexityMap.TryAdd(className, maintainability);
        }
    }

    private GameObject GetOrSpawnNode(Object obj, int depth, GameObject parentNodeObject = null, bool isAsset = false)
    {
        if (!obj) return null;

        var instanceId = obj.GetInstanceID();

        // Check if this node already exists
        if (_instanceIdToNodeLookup.TryGetValue(instanceId, out var existingNode))
        {
            // Connect existing node
            if (!parentNodeObject) return existingNode;
            if (isAsset)
                parentNodeObject.ConnectNodes(existingNode,
                    new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f), depth + 1,
                    "referenceConnection", ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);
            else
                parentNodeObject.ConnectNodes(existingNode,
                    obj switch
                    {
                        GameObject => new Color(parentChildConnection.r, parentChildConnection.g,
                            parentChildConnection.b, 0.5f),
                        Component => new Color(componentConnection.r, componentConnection.g, componentConnection.b,
                            0.5f),
                        _ => new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f)
                    }, depth, obj switch
                    {
                        GameObject => "parentChildConnection",
                        Component => "componentConnection",
                        _ => "referenceConnection"
                    }, ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);

            return existingNode;
        }

        // Create a new node
        var newNode = SpawnNode(obj, isAsset);
        _instanceIdToNodeLookup[instanceId] = newNode;
        if (!parentNodeObject) return newNode;
        if (isAsset)
            parentNodeObject.ConnectNodes(newNode,
                new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f), depth + 1,
                "referenceConnection", ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);
        else
            parentNodeObject.ConnectNodes(newNode,
                obj switch
                {
                    GameObject => new Color(parentChildConnection.r, parentChildConnection.g,
                        parentChildConnection.b, 0.5f),
                    Component => new Color(componentConnection.r, componentConnection.g, componentConnection.b,
                        0.5f),
                    _ => new Color(referenceConnection.r, referenceConnection.g, referenceConnection.b, 0.5f)
                }, depth, obj switch
                {
                    GameObject => "parentChildConnection",
                    Component => "componentConnection",
                    _ => "referenceConnection"
                }, ScriptableObjectInventory.Instance.nodeColors.maxWidthHierarchy);

        return newNode;
    }

    /// <summary>
    /// Find existing node by component type
    /// </summary>
    /// <param name="componentType"></param>
    /// <returns></returns>
    private GameObject FindNodeByComponentType(Type componentType)
    {
        foreach (var kvp in _instanceIdToNodeLookup)
        {
            var nodeType = kvp.Value.GetComponent<NodeType>();
            if (nodeType?.reference is Component comp && comp.GetType() == componentType)
            {
                return kvp.Value;
            }
        }

        return null;
    }

    /// <summary>
    /// Find an existing node or create a new one for the component type
    /// </summary>
    /// <param name="componentType"></param>
    /// <returns></returns>
    private GameObject FindOrCreateNodeForComponentType(Type componentType)
    {
        var existingNode = FindNodeByComponentType(componentType);
        return existingNode ? existingNode : SpawnNode(null, false, componentType);
    }

    /// <summary>
    /// Spawn a node gameObject in the overlay scene.
    /// If "virtualType" is provided, a virtual node representing that component type is created.
    /// </summary>
    /// <param name="obj">The object to represent; for virtual nodes this is null.</param>
    /// <param name="isAsset">Mark as an asset if needed.</param>
    /// <param name="virtualType">If non-null, indicates that a virtual node should be created for the given component type.</param>
    /// <returns>The spawned node GameObject.</returns>
    private GameObject SpawnNode(Object obj, bool isAsset = false, Type virtualType = null)
    {
        GameObject nodeObject = CreateNodeInstance();
        if (nodeObject == null)
            return null;

        ConfigureNodeType(nodeObject, obj, virtualType);
        AddArtificialGameObjectComponent(nodeObject);
        AddTextChild(nodeObject, obj, virtualType);

#if UNITY_EDITOR
        // Only add an icon for non-virtual nodes.
        if (virtualType == null)
            AddIcon(nodeObject, obj);
#endif

        ConfigureNodeName(nodeObject, obj, virtualType);
        ApplyNodeColor(nodeObject, obj, isAsset, virtualType);

        // For virtual nodes, store the node using a fake negative instance ID.
        if (virtualType == null) return nodeObject;
        int fakeInstanceId = -(virtualType.GetHashCode());

        // Add the virtual node immediately to all nodes.
        _instanceIdToNodeLookup[fakeInstanceId] = nodeObject;
        if (ScriptableObjectInventory.Instance.graph.AllNodes is { Count: > 0 } && nodeObject)
            ScriptableObjectInventory.Instance.graph.AllNodes.Add(nodeObject);

        return nodeObject;
    }

    /// <summary>
    /// Creates a new node instance using the prefab and ensures the parent and camera are valid.
    /// </summary>
    private GameObject CreateNodeInstance()
    {
        if (!ScriptableObjectInventory.Instance.overlay.GetCameraOfScene())
        {
            Debug.Log("No camera while trying to spawn a node in NodeBuilder");
            return null;
        }

        if (!parentNode)
        {
            parentNode = ScriptableObjectInventory.Instance.overlay.GetNodeGraph();
            if (!parentNode)
                Debug.Log("Node graph game object was not found");
        }

        GameObject nodeObject = Instantiate(nodePrefab, parentNode.transform);
        _currentNodes++;
        nodeObject.transform.localPosition = Vector3.zero;
        nodeObject.transform.localScale = new Vector3(nodeWidth, nodeHeight, 1f);
        nodeObject.layer = LayerMask.NameToLayer("OverlayScene");
        return nodeObject;
    }

    /// <summary>
    /// Configures the NodeType component on the node.
    /// For a virtual node - which is used for either Event/Dynamic reference (when virtualType is not null),
    /// the node is marked as a component node with no reference.
    /// Otherwise, it is assigned based on the supplied object.
    /// </summary>
    private static void ConfigureNodeType(GameObject nodeObject, Object obj, Type virtualType)
    {
        var nodeType = nodeObject.GetComponent<NodeType>();
        if (!nodeType) return;
        if (virtualType != null)
        {
            nodeType.reference = null;
            nodeType.nodeTypeName = NodeTypeName.Component;
        }
        else
        {
            nodeType.SetNodeType(obj);
            nodeType.reference = obj;
        }
    }

    /// <summary>
    /// Adds the ArtificialGameObject component to prevent recursive spawns on analyzing the overlay scene itself.
    /// </summary>
    private static void AddArtificialGameObjectComponent(GameObject nodeObject)
    {
        nodeObject.AddComponent<ArtificialGameObject>();
    }

    /// <summary>
    /// Adds a Text child (using TextMeshPro) to display a label on the node.
    /// For a virtual node the text is set to the type name (in parentheses).
    /// </summary>
    private static void AddTextChild(GameObject nodeObject, Object obj, Type virtualType)
    {
        var textObj = new GameObject("Text");
        textObj.transform.SetParent(nodeObject.transform);
        textObj.transform.localPosition = new Vector3(0, 0.6f, -1f);

        var text = textObj.AddComponent<TextMeshPro>();
        if (virtualType != null)
        {
            text.text = $"({virtualType.Name})";
        }
        else
        {
            text.text = obj ? obj.name : "null object";
        }

        text.alignment = TextAlignmentOptions.Center;
        text.fontSize = 1.5f;
    }

#if UNITY_EDITOR
    /// <summary>
    /// Adds an Icon child to the node when appropriate.
    /// Only non-virtual nodes (and when setIcons is enabled) will configure an icon.
    /// </summary>
    private void AddIcon(GameObject nodeObject, Object obj)
    {
        if (obj is not Component componentObject || !setIcons) return;
        var componentIcon = EditorGUIUtility.ObjectContent(null, componentObject.GetType()).image as Texture2D;
        if (!componentIcon) return;
        var iconObj = new GameObject("Icon");
        iconObj.transform.SetParent(nodeObject.transform);
        iconObj.transform.localPosition = new Vector3(0, 0, -1f);

        SpriteRenderer iconRenderer = iconObj.AddComponent<SpriteRenderer>();
        var sprite = TextureToSprite(componentIcon);
        iconRenderer.sprite = sprite;
        iconRenderer.sortingOrder = 1;

        const float desiredHeight = 0.5f;
        Vector2 spriteSize = sprite.bounds.size;
        float scaleY = desiredHeight / spriteSize.y;
        float scaleX = scaleY * (spriteSize.x / spriteSize.y) * 0.5f; // nodes are scale 2:1
        iconObj.transform.localScale = new Vector3(scaleX, scaleY, 1);
    }
#endif
    /// <summary>
    /// Configures the node's name based on its type and reference.
    /// For virtual nodes the name is prefixed with "virtual_co_" and the type name.
    /// </summary>
    private void ConfigureNodeName(GameObject nodeObject, Object obj, Type virtualType)
    {
        var nodeType = nodeObject.GetComponent<NodeType>();
        if (virtualType != null)
        {
            nodeObject.name = $"virtual_co_{virtualType.Name}";
        }
        else
        {
            var prefixNode = "";
            if (nodeType == null) return;
            prefixNode = nodeType.nodeTypeName switch
            {
                NodeTypeName.GameObject => "go_",
                NodeTypeName.Component => "co_",
                NodeTypeName.ScriptableObject => "so_",
                _ => prefixNode
            };

            // If no reference, this is the root
            if (nodeType.reference == null)
            {
                nodeObject.name = "tfRoot";
                nodeType.nodeTypeName = NodeTypeName.GameObject;
            }
            else
            {
                string postfixNode = prefixNode != "go_" ? "_" + nodeType.reference.GetType().Name : string.Empty;
                nodeObject.name = $"{prefixNode}{obj.name}{postfixNode}";
            }
        }
    }
    
    /// <summary>
    /// Applies colors to the node. For virtual nodes the node color is set using a dimmed version of the component color;
    /// for a normal object the node is colored based on whether it is a prefab or not.
    /// </summary>
    private void ApplyNodeColor(GameObject nodeObject, Object obj, bool isAsset, Type virtualType)
    {
        if (virtualType != null)
        {
            // Use a dimmed version of the component color to denote a virtual node.
            Color dimmedColor = dynamicComponentConnection;
            nodeObject.SetNodeColor(obj, gameObjectColor, dimmedColor, scriptableObjectColor, assetColor,
                overrideColor: dimmedColor);
        }
        else
        {
            if (!IsPrefab(obj))
            {
                nodeObject.SetNodeColor(obj, gameObjectColor, componentColor, scriptableObjectColor, assetColor,
                    isAsset);
            }
            else
            {
                // For prefabs, enable an emission effect.
                var nodeRenderer = nodeObject.GetComponent<Renderer>();
                if (!nodeRenderer) return;
                nodeRenderer.material.EnableKeyword("_EMISSION");
                Color emissionColor = Color.HSVToRGB(0.1f, 1f, 1f) * 5.0f; // White with intensity
                nodeRenderer.material.SetColor(EmissionColor, emissionColor);
            }
        }
    }
    
    [UsedImplicitly]
    private static Sprite TextureToSprite(Texture2D texture)
    {
        return Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f), 100f);
    }
}